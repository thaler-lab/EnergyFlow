<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Patrick T. Komiske III, Eric M. Metodiev">
  <link rel="canonical" href="https://energyflow.network/docs/utils/">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Utils - EnergyFlow</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../../css/eftheme.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Utils";
    var mkdocs_page_input_path = "docs/utils.md";
    var mkdocs_page_url = "/docs/utils/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-122962541-1', 'energyflow.network');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
  <a href="../..">
    <div class="eflogo">
      <img src="../../img/eflogowhite.png"  class="eflogo-img"> EnergyFlow
    </div>
  </a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Getting Started</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../installation/">Installation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../demos/">Demos</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../faqs/">FAQs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../releases/">Release Notes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../news/">News</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../archs/">Architectures</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../datasets/">Datasets</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../emd/">EMD</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../efm/">Energy Flow Moments</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../efp/">Energy Flow Polynomials</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../measures/">Measures</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../gen/">Multigraph Generation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../obs/">Observables</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Utils</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#particle-tools">Particle Tools</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#ptyphims_from_p4s">ptyphims_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pts_from_p4s">pts_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pt2s_from_p4s">pt2s_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ys_from_p4s">ys_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#etas_from_p4s">etas_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#phis_from_p4s">phis_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#m2s_from_p4s">m2s_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ms_from_p4s">ms_from_p4s</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ms_from_ps">ms_from_ps</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#etas_from_pts_ys_ms">etas_from_pts_ys_ms</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ys_from_pts_etas_ms">ys_from_pts_etas_ms</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#p4s_from_ptyphims">p4s_from_ptyphims</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#p4s_from_ptyphipids">p4s_from_ptyphipids</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sum_ptyphims">sum_ptyphims</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sum_ptyphipids">sum_ptyphipids</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#center_ptyphims">center_ptyphims</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rotate_ptyphims">rotate_ptyphims</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reflect_ptyphims">reflect_ptyphims</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pids2ms">pids2ms</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pids2chrgs">pids2chrgs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ischrgd">ischrgd</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#phi_fix">phi_fix</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#flat_metric">flat_metric</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#random-events">Random Events</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#gen_random_events">gen_random_events</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#gen_random_events_mcom">gen_random_events_mcom</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#gen_massless_phase_space">gen_massless_phase_space</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data-tools">Data Tools</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#get_examples">get_examples</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#data_split">data_split</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#to_categorical">to_categorical</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#remap_pids">remap_pids</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#image-tools">Image Tools</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#pixelate">pixelate</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#standardize">standardize</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#zero_center">zero_center</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#fastjet-tools">FastJet Tools</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#pjs_from_ptyphims">pjs_from_ptyphims</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ptyphims_from_pjs">ptyphims_from_pjs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cluster">cluster</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#softdrop">softdrop</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">EnergyFlow</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Utils</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="utilities">Utilities</h1>
<h2 id="particle-tools">Particle Tools</h2>
<p>Tools for dealing with particle momenta four-vectors. A four-vector can either
be in Cartesian coordinates, <code>[e,px,py,pz]</code> (energy, momentum in <code>x</code> direction,
momentum in <code>y</code> direction, momentum in <code>z</code> direction), or hadronic coordinates, 
<code>[pt,y,phi,m]</code> (transverse momentum, rapidity, azimuthal angle, mass), which
are related via:</p>
<div>
<div class="MathJax_Preview">p_T=\sqrt{p_x^2+p_y^2},\quad y=\text{arctanh}\,\frac{p_z}{E},\quad 
\phi=\arctan_2\frac{p_y}{p_x},\quad m=\sqrt{E^2-p_x^2-p_y^2-p_z^2}</div>
<script type="math/tex; mode=display">p_T=\sqrt{p_x^2+p_y^2},\quad y=\text{arctanh}\,\frac{p_z}{E},\quad 
\phi=\arctan_2\frac{p_y}{p_x},\quad m=\sqrt{E^2-p_x^2-p_y^2-p_z^2}</script>
</div>
<p>and inversely:</p>
<div>
<div class="MathJax_Preview">E=\cosh y\sqrt{p_T^2+m^2},\quad p_x=p_T\cos\phi,\quad 
p_y=p_T\sin\phi,\quad p_z=\sinh y\sqrt{p_T^2+m^2}.</div>
<script type="math/tex; mode=display">E=\cosh y\sqrt{p_T^2+m^2},\quad p_x=p_T\cos\phi,\quad 
p_y=p_T\sin\phi,\quad p_z=\sinh y\sqrt{p_T^2+m^2}.</script>
</div>
<p>The pseudorapidity <code>eta</code> can be obtained from a Cartesian four-momentum as:</p>
<div>
<div class="MathJax_Preview">\eta=\text{arctanh}\,\frac{p_z}{|\vec p|},\quad 
|\vec p|\equiv\sqrt{p_x^2+p_y^2+p_z^2},</div>
<script type="math/tex; mode=display">\eta=\text{arctanh}\,\frac{p_z}{|\vec p|},\quad 
|\vec p|\equiv\sqrt{p_x^2+p_y^2+p_z^2},</script>
</div>
<p>and is related to the rapidity via</p>
<div>
<div class="MathJax_Preview">\eta=\text{arcsinh}\left(\sinh y\,\left(1+m^2/p_T^2\right)^{1/2}\right),\quad 
y=\text{arcsinh}\left(\sinh \eta\,\left(1+m^2/p_T^2\right)^{-1/2}\right).</div>
<script type="math/tex; mode=display">\eta=\text{arcsinh}\left(\sinh y\,\left(1+m^2/p_T^2\right)^{1/2}\right),\quad 
y=\text{arcsinh}\left(\sinh \eta\,\left(1+m^2/p_T^2\right)^{-1/2}\right).</script>
</div>
<p>Note that the above formulas are numerically stable up to values of rapidity or
pseudorapidity of a few hundred, above which the formulas have numerical issues. 
In this case, a different but equivalent formulae are used that are numerically
stable in this region. In all cases, the <span><span class="MathJax_Preview">p_T\to0</span><script type="math/tex">p_T\to0</script></span> limit produces infinite
values.</p>
<p>In the context of this package, an "event" is a two-dimensional numpy array
with shape <code>(M,4)</code> where <code>M</code> is the multiplicity. An array of events is a 
three-dimensional array with shape <code>(N,M,4)</code> where <code>N</code> is the number of events.
The valid inputs and outputs of the functions here will be described using
this terminology.</p>
<hr />
<h3 id="ptyphims_from_p4s">ptyphims_from_p4s</h3>
<pre><code class="language-python">energyflow.ptyphims_from_p4s(p4s, phi_ref=None, mass=True)
</code></pre>
<p>Convert to hadronic coordinates <code>[pt,y,phi,m]</code> from Cartesian
coordinates. All-zero four-vectors are left alone.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
<li><strong>phi_ref</strong> : {<code>None</code>, <code>'hardest'</code>, <em>float</em>, <em>numpy.ndarray</em>}<ul>
<li>Used to help deal with the fact that <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span> is a periodic coordinate.
If a float (which should be in <span><span class="MathJax_Preview">[0,2\pi)</span><script type="math/tex">[0,2\pi)</script></span>), all phi values will be
within <span><span class="MathJax_Preview">\pm\pi</span><script type="math/tex">\pm\pi</script></span> of this reference value. If <code>'\hardest'</code>, the phi of
the hardest particle is used as the reference value. If <code>None</code>, all
phis will be in the range <span><span class="MathJax_Preview">[0,2\pi)</span><script type="math/tex">[0,2\pi)</script></span>. An array is accepted in the case
that <code>p4s</code> is an array of events, in which case the <code>phi_ref</code> array
should have shape <code>(N,)</code> where <code>N</code> is the number of events.</li>
</ul>
</li>
<li><strong>mass</strong> : <em>bool</em><ul>
<li>Whether or not to include particle masses.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of hadronic four-momenta with the same shape as the input.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="pts_from_p4s">pts_from_p4s</h3>
<pre><code class="language-python">energyflow.pts_from_p4s(p4s)
</code></pre>
<p>Calculate the transverse momenta of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of transverse momenta with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="pt2s_from_p4s">pt2s_from_p4s</h3>
<pre><code class="language-python">energyflow.pt2s_from_p4s(p4s)
</code></pre>
<p>Calculate the squared transverse momenta of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of squared transverse momenta with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="ys_from_p4s">ys_from_p4s</h3>
<pre><code class="language-python">energyflow.ys_from_p4s(p4s)
</code></pre>
<p>Calculate the rapidities of a collection of four-vectors. Returns zero
for all-zero particles</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of rapidities with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="etas_from_p4s">etas_from_p4s</h3>
<pre><code class="language-python">energyflow.etas_from_p4s(p4s)
</code></pre>
<p>Calculate the pseudorapidities of a collection of four-vectors. Returns
zero for all-zero particles</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of pseudorapidities with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="phis_from_p4s">phis_from_p4s</h3>
<pre><code class="language-python">energyflow.phis_from_p4s(p4s, phi_ref=None)
</code></pre>
<p>Calculate the azimuthal angles of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
<li><strong>phi_ref</strong> : {<em>float</em>, <em>numpy.ndarray</em>, <code>None</code>, <code>'hardest'</code>}<ul>
<li>Used to help deal with the fact that <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span> is a periodic coordinate.
If a float (which should be in <span><span class="MathJax_Preview">[0,2\pi)</span><script type="math/tex">[0,2\pi)</script></span>), all phi values will be
within <span><span class="MathJax_Preview">\pm\pi</span><script type="math/tex">\pm\pi</script></span> of this reference value. If <code>'\hardest'</code>, the phi of
the hardest particle is used as the reference value. If <code>None</code>, all
phis will be in the range <span><span class="MathJax_Preview">[0,2\pi)</span><script type="math/tex">[0,2\pi)</script></span>. An array is accepted in the case
that <code>p4s</code> is an array of events, in which case the <code>phi_ref</code> array
should have shape <code>(N,)</code> where <code>N</code> is the number of events.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of azimuthal angles with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="m2s_from_p4s">m2s_from_p4s</h3>
<pre><code class="language-python">energyflow.m2s_from_p4s(p4s)
</code></pre>
<p>Calculate the squared masses of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of squared masses with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="ms_from_p4s">ms_from_p4s</h3>
<pre><code class="language-python">energyflow.ms_from_p4s(p4s)
</code></pre>
<p>Calculate the masses of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of masses with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="ms_from_ps">ms_from_ps</h3>
<pre><code class="language-python">energyflow.ms_from_ps(ps)
</code></pre>
<p>Calculate the masses of a collection of Lorentz vectors in two or more
spacetime dimensions.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ps</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian
coordinates in <span><span class="MathJax_Preview">d\ge2</span><script type="math/tex">d\ge2</script></span> spacetime dimensions.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of masses with shape <code>ps.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="etas_from_pts_ys_ms">etas_from_pts_ys_ms</h3>
<pre><code class="language-python">energyflow.etas_from_pts_ys_ms(pts, ys, ms)
</code></pre>
<p>Calculate pseudorapidities from transverse momenta, rapidities, and masses.
All input arrays should have the same shape.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pts</strong> : <em>numpy.ndarray</em><ul>
<li>Array of transverse momenta.</li>
</ul>
</li>
<li><strong>ys</strong> : <em>numpy.ndarray</em><ul>
<li>Array of rapidities.</li>
</ul>
</li>
<li><strong>ms</strong> : <em>numpy.ndarray</em><ul>
<li>Array of masses.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of pseudorapidities with the same shape as <code>ys</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="ys_from_pts_etas_ms">ys_from_pts_etas_ms</h3>
<pre><code class="language-python">energyflow.ys_from_pts_etas_ms(pts, etas, ms)
</code></pre>
<p>Calculate rapidities from transverse momenta, pseudorapidities, and masses.
All input arrays should have the same shape.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pts</strong> : <em>numpy.ndarray</em><ul>
<li>Array of transverse momenta.</li>
</ul>
</li>
<li><strong>etas</strong> : <em>numpy.ndarray</em><ul>
<li>Array of pseudorapidities.</li>
</ul>
</li>
<li><strong>ms</strong> : <em>numpy.ndarray</em><ul>
<li>Array of masses.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of rapidities with the same shape as <code>etas</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="p4s_from_ptyphims">p4s_from_ptyphims</h3>
<pre><code class="language-python">energyflow.p4s_from_ptyphims(ptyphims)
</code></pre>
<p>Calculate Cartesian four-vectors from transverse momenta, rapidities,
azimuthal angles, and (optionally) masses for each input.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in hadronic coordinates.
The mass is optional and if left out will be taken to be zero.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of Cartesian four-vectors.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="p4s_from_ptyphipids">p4s_from_ptyphipids</h3>
<pre><code class="language-python">energyflow.p4s_from_ptyphipids(ptyphipids, error_on_unknown=False)
</code></pre>
<p>Calculate Cartesian four-vectors from transverse momenta, rapidities,
azimuthal angles, and particle IDs for each input. The particle IDs are
used to lookup the mass of the particle. Transverse momenta should have
units of GeV when using this function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphipids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in hadronic coordinates
where the mass is replaced by the PDG ID of the particle.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>See the corresponding argument of <a href="#pids2ms"><code>pids2ms</code></a>.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of Cartesian four-vectors with the same shape as the input.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="sum_ptyphims">sum_ptyphims</h3>
<pre><code class="language-python">energyflow.sum_ptyphims(ptyphims, scheme='escheme')
</code></pre>
<p>Add a collection of four-vectors that are expressed in hadronic
coordinates by first converting to Cartesian coordinates and then summing.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An event in hadronic coordinates. The mass is optional and if left
out will be taken to be zero.</li>
</ul>
</li>
<li><strong>scheme</strong> : <em>str</em><ul>
<li>A string specifying a recombination scheme for adding four-vectors
together. Currently supported options are <code>'escheme'</code>, which adds the
vectors in Cartesian coordinates, and <code>'ptscheme'</code>, which sums the pTs
of each particle and places the jet axis at the pT-weighted centroid
in the rapidity-azimuth plane. Note that <code>'ptscheme'</code> will return a
three-vector consisting of the jet <code>[pT,y,phi]</code> with no mass value.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of summed four-vectors, in hadronic coordinates. Note that when
<code>scheme</code> is <code>'escheme'</code>, the <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span> value of the hardest particle is
used as the <code>phi_ref</code> when converting back to hadronic coordinates.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="sum_ptyphipids">sum_ptyphipids</h3>
<pre><code class="language-python">energyflow.sum_ptyphipids(ptyphipids, scheme='escheme', error_on_unknown=False)
</code></pre>
<p>Add a collection of four-vectors that are expressed as
<code>[pT,y,phi,pdgid]</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphipids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle or event in hadronic coordinates where the mass
is replaced by the PDG ID of the particle.</li>
</ul>
</li>
<li><strong>scheme</strong> : <em>str</em><ul>
<li>See the argument of the same name of <a href="#sum_ptyphims"><code>sum_ptyphims</code></a>.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>See the corresponding argument of <a href="#pids2ms"><code>pids2ms</code></a>.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of summed four-vectors, in hadronic coordinates. Note that when
<code>scheme</code> is <code>'escheme'</code>, the <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span> value of the hardest particle is
used as the <code>phi_ref</code> when converting back to hadronic coordinates.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="center_ptyphims">center_ptyphims</h3>
<pre><code class="language-python">energyflow.center_ptyphims(ptyphims, axis=None, center='escheme', copy=True)
</code></pre>
<p>Center a collection of four-vectors according to a calculated or 
provided axis.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An event in hadronic coordinates. The mass is optional and if left
out will be taken to be zero.</li>
</ul>
</li>
<li><strong>axis</strong> : <em>numpy.ndarray</em><ul>
<li>If not <code>None</code>, the <code>[y,phi]</code> values to use for centering.</li>
</ul>
</li>
<li><strong>center</strong> : <em>str</em><ul>
<li>The centering scheme to be used. Valid options are the same as the
<code>scheme</code> argument of <a href="#sum_ptyphims"><code>sum_ptyphims</code></a>.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input array.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of hadronic four-momenta with the positions centered around
the origin.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="rotate_ptyphims">rotate_ptyphims</h3>
<pre><code class="language-python">energyflow.rotate_ptyphims(ptyphims, rotate='ptscheme', center=None, copy=True)
</code></pre>
<p>Rotate a collection of four-vectors to vertically align the principal
component of the energy flow. The principal component is obtained as the
eigenvector of the energy flow with the largest eigenvalue. It is only
defined up to a sign, however it is ensured that there is more total pT in 
the top half of the rapidity-azimuth plane.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An event in hadronic coordinates. The mass is optional and if left
out will be taken to be zero.</li>
</ul>
</li>
<li><strong>rotate</strong> : <em>str</em><ul>
<li>The rotation scheme to be used. Currently, only <code>'ptscheme'</code> is
supported, which causes the rotation to take place in the 
rapidity-azimuth plane.</li>
</ul>
</li>
<li><strong>center</strong> : <em>str</em> or <code>None</code><ul>
<li>If not <code>None</code>, the event will be centered prior to rotation and this
argument will be passed on to <code>center_ptyphims</code> as the centering
scheme.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input array.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of hadronic four-momenta with the positions rotated around
the origin.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="reflect_ptyphims">reflect_ptyphims</h3>
<pre><code class="language-python">energyflow.reflect_ptyphims(ptyphims, which='both', center=None, copy=True)
</code></pre>
<p>Reflect a collection of four-vectors to arrange the highest-pT
half or quadrant to have positive rapidity-azimuth coordinates.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em><ul>
<li>An event in hadronic coordinates. The mass is optional and is not
used as a part of this function.</li>
</ul>
</li>
<li><strong>which</strong> : {<code>'both'</code>, <code>'x'</code>, <code>'y'</code>}<ul>
<li>Controls which axes to consider reflecting over. <code>'both'</code> includes
<code>'x'</code> and <code>'y'</code>.</li>
</ul>
</li>
<li><strong>center</strong> : <em>str</em> or <code>None</code><ul>
<li>If not <code>None</code>, the centering scheme to use prior to performing
reflections.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input array.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="pids2ms">pids2ms</h3>
<pre><code class="language-python">energyflow.pids2ms(pids, error_on_unknown=False)
</code></pre>
<p>Map an array of <a href="http://pdg.lbl.gov/2018/
reviews/rpp2018-rev-monte-carlo-numbering.pdf">Particle Data Group IDs</a> to an array of the
corresponding particle masses (in GeV).</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An array of numeric (float or integer) PDG ID values.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>Controls whether a <code>KeyError</code> is raised if an unknown PDG ID is
encountered. If <code>False</code>, unknown PDG IDs will map to zero.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of masses in GeV.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="pids2chrgs">pids2chrgs</h3>
<pre><code class="language-python">energyflow.pids2chrgs(pids, error_on_unknown=False)
</code></pre>
<p>Map an array of <a href="http://pdg.lbl.gov/2018/
reviews/rpp2018-rev-monte-carlo-numbering.pdf">Particle Data Group IDs</a> to an array of the
corresponding particle charges (in fundamental units where the charge
of the electron is -1).</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An array of numeric (float or integer) PDG ID values.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>Controls whether a <code>KeyError</code> is raised if an unknown PDG ID is
encountered. If <code>False</code>, unknown PDG IDs will map to zero.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of charges as floats.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="ischrgd">ischrgd</h3>
<pre><code class="language-python">energyflow.ischrgd(pids, ignored_pids=None)
</code></pre>
<p>Compute a boolean mask according to if the given PDG ID corresponds
to a particle of non-zero charge.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pids</strong> : <em>numpy.ndarray</em><ul>
<li>An array of numeric (float or integer) PDG ID values.</li>
</ul>
</li>
<li><strong>ignored_pids</strong> : <em>numpy.ndarray</em> or <code>None</code><ul>
<li>If not <code>None</code>, the PDG IDs in this array will not be considered
charged, for instance to avoid counting quarks as charged particles.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>A boolean mask corresponding to which particles are charged.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="phi_fix">phi_fix</h3>
<pre><code class="language-python">energyflow.phi_fix(phis, phi_ref, copy=True)
</code></pre>
<p>A function to ensure that all phis are within <span><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span> of <code>phi_ref</code>. It is
assumed that all starting phi values are <span><span class="MathJax_Preview">\pm 2\pi</span><script type="math/tex">\pm 2\pi</script></span> of <code>phi_ref</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>phis</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>Array of phi values.</li>
</ul>
</li>
<li><strong>phi_ref</strong> : {<em>float</em> or <em>numpy.ndarray</em>}<ul>
<li>A reference value used so that all phis will be within <span><span class="MathJax_Preview">\pm\pi</span><script type="math/tex">\pm\pi</script></span> of
this value. Should have a shape of <code>phis.shape[:-1]</code>.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Determines if <code>phis</code> are copied or not. If <code>False</code> then <code>phis</code> is
modified in place.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of the fixed phi values.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="flat_metric">flat_metric</h3>
<pre><code class="language-python">energyflow.flat_metric(dim)
</code></pre>
<p>The Minkowski metric in <code>dim</code> spacetime dimensions in the mostly-minus
convention.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>dim</strong> : <em>int</em><ul>
<li>The number of spacetime dimensions (thought to be four in our 
universe).</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>1-d numpy.ndarray</em><ul>
<li>A <code>dim</code>-length, one-dimensional (not matrix) array equal to 
<code>[+1,-1,...,-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="random-events">Random Events</h2>
<p>Functions to generate random sets of four-vectors. Includes an implementation
of the <a href="https://doi.org/10.1016/0010-4655(86)90119-0">RAMBO</a> algorithm for
sampling uniform M-body massless phase space. Also includes other functions for
various random, non-center of momentum, and non-uniform sampling.</p>
<hr />
<h3 id="gen_random_events">gen_random_events</h3>
<pre><code class="language-python">energyflow.gen_random_events(nevents, nparticles, dim=4, mass=0.0)
</code></pre>
<p>Generate random events with a given number of particles in a given
spacetime dimension. The spatial components of the momenta are
distributed uniformly in <span><span class="MathJax_Preview">[-1,+1]</span><script type="math/tex">[-1,+1]</script></span>. These events are not guaranteed to 
uniformly sample phase space.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>nevents</strong> : <em>int</em><ul>
<li>Number of events to generate.</li>
</ul>
</li>
<li><strong>nparticles</strong> : <em>int</em><ul>
<li>Number of particles in each event.</li>
</ul>
</li>
<li><strong>dim</strong> : <em>int</em><ul>
<li>Number of spacetime dimensions.</li>
</ul>
</li>
<li><strong>mass</strong> : <em>float</em> or <code>'random'</code><ul>
<li>Mass of the particles to generate. Can be set to <code>'random'</code> to obtain
a different random mass for each particle.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An <code>(nevents,nparticles,dim)</code> array of events. The particles 
are specified as <code>[E,p1,p2,...]</code>. If <code>nevents</code> is 1 then that axis is
dropped.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="gen_random_events_mcom">gen_random_events_mcom</h3>
<pre><code class="language-python">energyflow.gen_random_events_mcom(nevents, nparticles, dim=4)
</code></pre>
<p>Generate random events with a given number of massless particles in a
given spacetime dimension. The total momentum are made to sum
to zero. These events are not guaranteed to uniformly sample phase space.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>nevents</strong> : <em>int</em><ul>
<li>Number of events to generate.</li>
</ul>
</li>
<li><strong>nparticles</strong> : <em>int</em><ul>
<li>Number of particles in each event.</li>
</ul>
</li>
<li><strong>dim</strong> : <em>int</em><ul>
<li>Number of spacetime dimensions.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An <code>(nevents,nparticles,dim)</code> array of events. The particles 
are specified as <code>[E,p1,p2,...]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="gen_massless_phase_space">gen_massless_phase_space</h3>
<pre><code class="language-python">energyflow.gen_massless_phase_space(nevents, nparticles, energy=1.0)
</code></pre>
<p>Implementation of the <a href="https://doi.org/10.1016/0010-4655(86)90119-0">RAMBO</a>
algorithm for uniformly sampling massless M-body phase space for any center
of mass energy.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>nevents</strong> : <em>int</em><ul>
<li>Number of events to generate.</li>
</ul>
</li>
<li><strong>nparticles</strong> : <em>int</em><ul>
<li>Number of particles in each event.</li>
</ul>
</li>
<li><strong>energy</strong> : <em>float</em><ul>
<li>Total center of mass energy of each event.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An <code>(nevents,nparticles,4)</code> array of events. The particles 
are specified as <code>[E,p_x,p_y,p_z]</code>. If <code>nevents</code> is 1 then that axis is
dropped.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="data-tools">Data Tools</h2>
<p>Functions for dealing with datasets. These are not importable from
the top level <code>energyflow</code> module, but must instead be imported 
from <code>energyflow.utils</code>.</p>
<hr />
<h3 id="get_examples">get_examples</h3>
<pre><code class="language-python">energyflow.utils.get_examples(path='~/.energyflow', which='all', overwrite=False)
</code></pre>
<p>Pulls examples from GitHub. To ensure availability of all examples
update EnergyFlow to the latest version.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>path</strong> : <em>str</em><ul>
<li>The destination for the downloaded files. Note that <code>examples</code>
is automatically appended to the end of this path.</li>
</ul>
</li>
<li><strong>which</strong> : {<em>list</em>, <code>'all'</code>}<ul>
<li>List of examples to download, or the string <code>'all'</code> in which 
case all the available examples are downloaded.</li>
</ul>
</li>
<li><strong>overwrite</strong> : <em>bool</em><ul>
<li>Whether to overwrite existing files or not.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="data_split">data_split</h3>
<pre><code class="language-python">energyflow.utils.data_split(*args, train=-1, val=0.0, test=0.1, shuffle=True)
</code></pre>
<p>A function to split a dataset into train, test, and optionally 
validation datasets.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong> : arbitrary <em>numpy.ndarray</em> datasets<ul>
<li>An arbitrary number of datasets, each required to have
the same number of elements, as numpy arrays.</li>
</ul>
</li>
<li><strong>train</strong> : {<em>int</em>, <em>float</em>}<ul>
<li>If a float, the fraction of elements to include in the training
set. If an integer, the number of elements to include in the
training set. The value <code>-1</code> is special and means include the
remaining part of the dataset in the training dataset after
the test and (optionally) val parts have been removed</li>
</ul>
</li>
<li><strong>val</strong> : {<em>int</em>, <em>float</em>}<ul>
<li>If a float, the fraction of elements to include in the validation
set. If an integer, the number of elements to include in the
validation set. The value <code>0</code> is special and means do not form
a validation set.</li>
</ul>
</li>
<li><strong>test</strong> : {<em>int</em>, <em>float</em>}<ul>
<li>If a float, the fraction of elements to include in the test
set. If an integer, the number of elements to include in the
test set.</li>
</ul>
</li>
<li><strong>shuffle</strong> : <em>bool</em><ul>
<li>A flag to control whether the dataset is shuffled prior to
being split into parts.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em><ul>
<li>A list of the split datasets in train, [val], test order. If 
datasets <code>X</code>, <code>Y</code>, and <code>Z</code> were given as <code>args</code> (and assuming a
non-zero <code>val</code>), then [<code>X_train</code>, <code>X_val</code>, <code>X_test</code>, <code>Y_train</code>, 
<code>Y_val</code>, <code>Y_test</code>, <code>Z_train</code>, <code>Z_val</code>, <code>Z_test</code>] will be returned.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="to_categorical">to_categorical</h3>
<pre><code class="language-python">energyflow.utils.to_categorical(labels, num_classes=None)
</code></pre>
<p>One-hot encodes class labels.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>labels</strong> : <em>1-d numpy.ndarray</em><ul>
<li>Labels in the range <code>[0,num_classes)</code>.</li>
</ul>
</li>
<li><strong>num_classes</strong> : {<em>int</em>, <code>None</code>}<ul>
<li>The total number of classes. If <code>None</code>, taken to be the 
maximum label plus one.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>2-d numpy.ndarray</em><ul>
<li>The one-hot encoded labels.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="remap_pids">remap_pids</h3>
<pre><code class="language-python">energyflow.utils.remap_pids(events, pid_i=3, error_on_unknown=True)
</code></pre>
<p>Remaps PDG id numbers to small floats for use in a neural network.
<code>events</code> are modified in place and nothing is returned.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>events</strong> : <em>numpy.ndarray</em><ul>
<li>The events as an array of arrays of particles.</li>
</ul>
</li>
<li><strong>pid_i</strong> : <em>int</em><ul>
<li>The column index corresponding to pid information in an event.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>Controls whether a <code>KeyError</code> is raised if an unknown PDG ID is
encountered. If <code>False</code>, unknown PDG IDs will map to zero.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="image-tools">Image Tools</h2>
<p>Functions for dealing with image representations of events. These are 
not importable from the top level <code>energyflow</code> module, but must 
instead be imported from <code>energyflow.utils</code>.</p>
<hr />
<h3 id="pixelate">pixelate</h3>
<pre><code class="language-python">energyflow.utils.pixelate(jet, npix=33, img_width=0.8, nb_chan=1, norm=True, charged_counts_only=False)
</code></pre>
<p>A function for creating a jet image from an array of particles.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>jet</strong> : <em>numpy.ndarray</em><ul>
<li>An array of particles where each particle is of the form 
<code>[pt,y,phi,pid]</code> where the particle id column is only 
used if <code>nb_chan=2</code> and <code>charged_counts_only=True</code>.</li>
</ul>
</li>
<li><strong>npix</strong> : <em>int</em><ul>
<li>The number of pixels on one edge of the jet image, which is
taken to be a square.</li>
</ul>
</li>
<li><strong>img_width</strong> : <em>float</em><ul>
<li>The size of one edge of the jet image in the rapidity-azimuth
plane.</li>
</ul>
</li>
<li><strong>nb_chan</strong> : {<code>1</code>, <code>2</code>}<ul>
<li>The number of channels in the jet image. If <code>1</code>, then only a
<span><span class="MathJax_Preview">p_T</span><script type="math/tex">p_T</script></span> channel is constructed (grayscale). If <code>2</code>, then both a 
<span><span class="MathJax_Preview">p_T</span><script type="math/tex">p_T</script></span> channel and a count channel are formed (color).</li>
</ul>
</li>
<li><strong>norm</strong> : <em>bool</em><ul>
<li>Whether to normalize the <span><span class="MathJax_Preview">p_T</span><script type="math/tex">p_T</script></span> pixels to sum to <code>1</code>.</li>
</ul>
</li>
<li><strong>charged_counts_only</strong> : <em>bool</em><ul>
<li>If making a count channel, whether to only include charged 
particles. Requires that <code>pid</code> information be given.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>3-d numpy.ndarray</em><ul>
<li>The jet image as a <code>(npix, npix, nb_chan)</code> array. Note that the order
of the channels changed in version 1.0.3.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="standardize">standardize</h3>
<pre><code class="language-python">energyflow.utils.standardize(*args, channels=None, copy=False, reg=10**-10)
</code></pre>
<p>Normalizes each argument by the standard deviation of the pixels in 
args[0]. The expected use case would be <code>standardize(X_train, X_val, 
X_test)</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong> : arbitrary <em>numpy.ndarray</em> datasets<ul>
<li>An arbitrary number of datasets, each required to have
the same shape in all but the first axis.</li>
</ul>
</li>
<li><strong>channels</strong> : <em>int</em><ul>
<li>A list of which channels (assumed to be the last axis)
to standardize. <code>None</code> is interpretted to mean every channel.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input arrays before modifying them.</li>
</ul>
</li>
<li><strong>reg</strong> : <em>float</em><ul>
<li>Small parameter used to avoid dividing by zero. It's important
that this be kept consistent for images used with a given model.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em> <ul>
<li>A list of the now-standardized arguments.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="zero_center">zero_center</h3>
<pre><code class="language-python">energyflow.utils.zero_center(args, kwargs)
</code></pre>
<p>Subtracts the mean of arg[0] from the arguments. The expected 
use case would be <code>standardize(X_train, X_val, X_test)</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong> : arbitrary <em>numpy.ndarray</em> datasets<ul>
<li>An arbitrary number of datasets, each required to have
the same shape in all but the first axis.</li>
</ul>
</li>
<li><strong>channels</strong> : <em>int</em><ul>
<li>A list of which channels (assumed to be the last axis)
to zero center. <code>None</code> is interpretted to mean every channel.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input arrays before modifying them.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em> <ul>
<li>A list of the zero-centered arguments.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="fastjet-tools">FastJet Tools</h2>
<p>The <a href="http://fastjet.fr/">FastJet package</a> provides, among other things, fast
jet clustering utilities. It is written in C++ and includes a Python interface
that is easily installed at compile time by passing the <code>--enable-pyext</code> flag
to <code>configure</code>. If you use this module for published research, please <a href="http://fastjet.fr/about.html">cite
FastJet appropriately</a>.</p>
<p>The core of EnergyFlow does not rely on FastJet, and hence it is not required
to be installed, but the following utilities are available assuming that
<code>import fastjet</code> succeeds in your Python environment (if not, no warnings or
errors will be issued but this module will not be usable).</p>
<hr />
<h3 id="pjs_from_ptyphims">pjs_from_ptyphims</h3>
<pre><code class="language-python">energyflow.pjs_from_ptyphims(ptyphims)
</code></pre>
<p>Converts particles in hadronic coordinates to FastJet PseudoJets.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>2d numpy.ndarray</em><ul>
<li>An array of particles in hadronic coordinates. The mass is
optional and will be taken to be zero if not present.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em> of <em>fastjet.PseudoJet</em><ul>
<li>A list of PseudoJets corresponding to the particles in the given
array.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="ptyphims_from_pjs">ptyphims_from_pjs</h3>
<pre><code class="language-python">energyflow.ptyphims_from_pjs(pjs, phi_ref=None, mass=True)
</code></pre>
<p>Extracts hadronic four-vectors from FastJet PseudoJets.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pjs</strong> : <em>list</em> of <em>fastjet.PseudoJet</em><ul>
<li>An iterable of PseudoJets.</li>
</ul>
</li>
<li><strong>phi_ref</strong> : <em>float</em> or <code>None</code><ul>
<li>The reference phi value to use for phi fixing. If <code>None</code>, then no
phi fixing is performed.</li>
</ul>
</li>
<li><strong>mass</strong> : <em>bool</em><ul>
<li>Whether or not to include the mass in the extracted four-vectors.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of four-vectors corresponding to the given PseudoJets as
<code>[pT, y, phi, m]</code>, where the mass is optional.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="cluster">cluster</h3>
<pre><code class="language-python">energyflow.cluster(pjs, algorithm='ca', R=1000.0)
</code></pre>
<p>Clusters a list of PseudoJets according to a specified jet
algorithm and jet radius.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pjs</strong> : <em>list</em> of <em>fastjet.PseudoJet</em><ul>
<li>A list of Pseudojets representing particles or other kinematic
objects that are to be clustered into jets.</li>
</ul>
</li>
<li><strong>algorithm</strong> : {'kt', 'antikt', 'ca', 'cambridge', 'cambridge_aachen'}<ul>
<li>The jet algorithm to use during the clustering. Note that the
last three options all refer to the same strategy and are provided
because they are all used by the FastJet Python package.</li>
</ul>
</li>
<li><strong>R</strong> : <em>float</em><ul>
<li>The jet radius. The default value corresponds to
<code>max_allowable_R</code> as defined by the FastJet python package.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em> of <em>fastjet.PseudoJet</em><ul>
<li>A list of PseudoJets corresponding to the clustered jets.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="softdrop">softdrop</h3>
<pre><code class="language-python">energyflow.softdrop(jet, zcut=0.1, beta=0, R=1.0)
</code></pre>
<p>Implements the SoftDrop grooming algorithm on a jet that has been
found via clustering. Specifically, given a jet, it is recursively
declustered and the softer branch removed until the SoftDrop condition
is satisfied:</p>
<div>
<div class="MathJax_Preview">
\frac{\min(p_{T,1},p_{T,2})}{p_{T,1}+p_{T,2}} &gt; z_{\rm cut}
\left(\frac{\Delta R_{12}}{R}\right)^\beta
</div>
<script type="math/tex; mode=display">
\frac{\min(p_{T,1},p_{T,2})}{p_{T,1}+p_{T,2}} > z_{\rm cut}
\left(\frac{\Delta R_{12}}{R}\right)^\beta
</script>
</div>
<p>where <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> and <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> refer to the two PseudoJets declustered at this stage.
See the <a href="https://arxiv.org/abs/1402.2657">SoftDrop paper</a> for a
complete description of SoftDrop. If you use this function for your
research, please cite <a href="https://doi.org/10.1007/
JHEP05(2014)146">1402.2657</a>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>jet</strong> : <em>fastjet.PseudoJet</em><ul>
<li>A FastJet PseudoJet that has been obtained from a suitable
clustering (typically Cambridge/Aachen).</li>
</ul>
</li>
<li><strong>zcut</strong> : <em>float</em><ul>
<li>The <span><span class="MathJax_Preview">z_{\rm cut}</span><script type="math/tex">z_{\rm cut}</script></span> parameter of SoftDrop. Should be between <code>0</code>
and <code>1</code>.</li>
</ul>
</li>
<li><strong>beta</strong> : <em>int</em> or <em>float</em><ul>
<li>The <span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> parameter of SoftDrop.</li>
</ul>
</li>
<li><strong>R</strong> : <em>float</em><ul>
<li>The jet radius to use for the grooming. Only relevant if <code>beta!=0</code>.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>fastjet.PseudoJet</em><ul>
<li>The groomed jet. Note that it will not necessarily have all of
the same associated structure as the original jet, but it is
suitable for obtaining kinematic quantities, e.g. <a href="/docs/
obs/#zg_from_pj"><span><span class="MathJax_Preview">z_g</span><script type="math/tex">z_g</script></span></a>.</li>
</ul>
</li>
</ul>
<hr />
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../obs/" class="btn btn-neutral" title="Observables"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/pkomiske/EnergyFlow" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../obs/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../js/eftheme.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
